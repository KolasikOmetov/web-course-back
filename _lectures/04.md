# Особенности работы с БД

## SQL и ORM

ORM - технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных»

Среди достоинств ORM выделяют:

- наличие явного описания схемы БД, представленное в терминах какого-либо языка программирования, которое находится и редактируется в одном месте;
- возможность оперировать элементами языка программирования, т.е. классами, объектами, атрибутами, методами, а не элементами реляционной модели данных;
- возможность автоматического создания SQL-запросов, которая избавляет от необходимости использования языка для описания структуры БД (Data Definition Language) и языка манипулирования данными (Data Manipulation Language) при проектировании БД и изменении её схемы соответственно;
- не нужно создавать новые SQL-запросы при переносе на другую систему управления базами данных, поскольку за это отвечает низкоуровневый драйвер ORM.
- ORM избавляет от необходимости работы с SQL и проработки значительного количества программного кода, который зачастую однообразен и подвержен ошибкам.
- код, генерируемый ORM **гипотетически** проверен и ~~оптимизирован~~, следовательно не нужно беспокоиться о его тестировании;
- развитые реализации ORM поддерживают отображение наследования и композиции на таблицы;
- ORM дает возможность изолировать код программы от подробностей хранения данных.

Среди недостатков ORM выделяются:

- Дополнительная нагрузка на программиста, которому, в случае использования ORM необходимо изучать этот некий «дополнительный слой» между программной и базой данных, который к тому же создает дополнительный уровень абстракции — объекты ORM. В связи с этим могут возникнуть вопросы соответствия особенностям ООП и соответствующим реляционным операциям. Эту проблему называют impedance mismatch, а сама реализация ORM ведет к увеличению объема программного кода и снижению скорости работы программы. Однако, с другой стороны, ORM наглядно и в одном месте концентрирует различие между реляционной и объектно-ориентированной парадигмами, что нельзя назвать недостатком;
- Появление трудно поддающихся отладке ошибок в программе, если присутствуют ошибки в реализации ORM, например, ошибки в реализации кэширования ORM, такие как согласование изменений в разных сессиях.
- Недостатки реализаций, которые могут иметь определенные ограничения и выдвигать определенные требования, например, требование собственной схемы базы данных и ограничение на средства создания базы данных. Также может отсутствовать возможность написать в явном виде SQL-запрос.
- Требуются отдельные таблицы в случае прямого отображения классов в таблицы и необходимости отображения атрибутов множественного характера.

Если говорить о главном минусе ORM, снижении производительности, то причина этого состоит в том, что большинство из ORM нацелены на обработку значительного большего количества различных сценариев использования данных, чем в случае отдельного приложения. В случае небольших проектов, которые не сталкиваются с высокой нагрузкой, применение ORM очевидно, особенно, если учесть такой важный критерий разработки, как время.


## Code-First vs Model-First vs Database-First

**Model-First** — слово *Модель*  здесь означает  *визуальную диаграмму классов,*  построенную с помощью инструментов проектирования; эта диаграмма затем будет использоваться платформой для автоматического создания сценария SQL базы данных и файлов исходного кода модели данных.

Такой подход имеет следующие преимущества:

- Мы сможем создать схему базы данных и диаграмму классов, используя инструмент визуального дизайна, который может быть отличным, когда структура данных довольно большая.
- Всякий раз, когда база данных изменяется, модель может быть обновлена соответствующим образом без потери данных.

Но есть и недостатки ниже:

- Мало нам интерфейса БД и IDE, надо пользоваться еще одним инструментом.
- На  *диаграмме классов*, автогенерируемые сценарии SQL могут привести к потере данных в случае обновления. Что бы избежать этой проблемы придется вручную писать миграции и поддерживать в актуальном состоянии и диаграмму и БД.
- Работа с диаграммой может быть сложной, особенно если мы хотим иметь точный контроль над нашими классами модели; мы не всегда сможем получить то, что хотим, поскольку фактический исходный код будет автоматически сгенерирован инструментом.

**Database-First** — Отдельно создается и обновляется БД, а фреймворк сам сканирует модель БД и создает необходимые модели и связи.

Плюсы:

- Если у нас есть уже существующая база данных, это, скорее всего, будет правильным решением, поскольку это избавит нас от необходимости воссоздавать ее.
- Риск потери данных будет сведен к минимуму, потому что любые изменения или обновления всегда будут выполняться в базе данных.

Минусы:

- Обновление базы данных вручную может быть сложной задачей, если мы имеем дело с кластерами, несколькими экземплярами или несколькими средами разработки / тестирования / производства, поскольку нам придется вручную синхронизировать их, а не полагаться на обновления / миграции, управляемые кодом или автоматически сгенерированные сценарии SQL
- У нас будет даже меньше контроля над автоматически сгенерированными классами модели (и их исходным кодом), чем при использовании подхода *Model-First* ; для этого потребуются обширные знания конвертации и логики работы используемой ORM.

**Code-Firts** — подход позволяет разработчику определять объекты модели, описывая их при помощи инструментов ORM.

Плюсы:

- Нет необходимости в диаграммах и визуальных инструментах, что может быть отличным вариантом для проектов малого и среднего размера, так как это сэкономит нам много времени.

Минусы:

- Знания логики работы ORM становятся критичным. 


## Хранение данных

**Первичный ключ integer vs guid**
**Guid** — статистически уникальный 128-битный идентификатор. Его главная особенность — уникальность, которая позволяет создавать расширяемые сервисы и приложения без опасения конфликтов, вызванных совпадением идентификаторов. Хотя уникальность каждого отдельного GUID не гарантируется, общее количество уникальных ключей настолько велико (2128 или 3,4028×1038), что вероятность того, что в мире будут независимо сгенерированы два совпадающих ключа, крайне мала.

**Integer**

- Занимает меньший объем
- Теоретически, более быстрая генерация нового значения
- Более быстрая десериализация
- Проще оперировать при отладке, поддержке, так как число гораздо легче запомнить

**GUID**

- При репликации между несколькими экземплярами базы, где добавление новых записей происходит более, чем в одну реплику, GUID гарантирует отсутствие коллизий
- Позволяет генерировать идентификатор записи на клиенте, до сохранения ее в базу
- Обобщение первого пункта — обеспечивает уникальность идентификаторов не только в пределах одной таблицы, что для некоторых решений может быть важно
- Делает практически невозможным «угадывание» ключа в случаях, когда запись можно получить, передав ее идентификатор в какой-нибудь публичный API

**Как хранить файлы?**
Есть 2 подхода, blob объектами в бд или на диске (в бд только путь к файлу на диске/в облаке). С точки зрения технической реализации будет мало отличий. Если хранить как blob в  бд, то сама бд сохранит файл на диск и запомнит путь. Так в чем же разница?

Преимущества через blob в базе:

- Готовый механизм, не надо подключать новых библиотек или писать код для сохранения и чтения файлов.
- СУБД корректно обрабатывает одновременный доступ на изменение к одной и той же записи.
- Не надо думать об иерархии хранилища (если хранить на диске, то рекомендуется разбивать на папки и в папке хранить не более 1000 файлов)

Преимущества через ручное хранение на диске:

- Меньше нагрузка на бд.
- Бэкапить файлы не намного дольше, но восстанавливать можно по отдельным файлам, а не заливать весь дамп.
- Обращение к файлам и считывание быстрее, чем получение записи из БД (даже если используются сокеты).
- Кэширование файлов осуществляет автоматически ОС и сервер. А у СУБД кэширование больших файлов вызывает потерю производительности из-за вытеснения простых запросов из кэша.

**Даты. Datetime vs Bigint**
Можно использовать специальный формат, предназначенный для хранения дат, но часто можно увидеть, как даты хранятся в unix формате. По факту, что datetime, что bitint занимают 8 байт, поэтому отталкиваться от занимаемого места смысла нет.

Преимущества Bigint

- Не надо думать о часовом поясе.

Преимущества Datetime

- Наглядно и читабельно.
- Позволяет работать с датами на уровне sql кода


## SQL инъекции

**SQL инъекция** — это один из самых доступных способов взлома сайта.
Суть таких инъекций – внедрение в данные (передаваемые через GET, POST запросы или значения Cookie) произвольного SQL кода. Если сайт уязвим и выполняет такие инъекции, то по сути есть возможность творить с БД (чаще всего это MySQL) что угодно.

Как выглядит инъекция. Предположим у вас есть магазин и одна из страниц отображает категории:
`https://insecure-website.com/products?category=Gifts`
А запрос для получения категории выглядит следующим образом:
`SELECT * FROM products WHERE category = 'Gifts' AND released = 1`

Если сайт уязвим к SQL инъекциям, то можно попробовать передать следующую конструкцию:
`https://insecure-website.com/products?category=Gifts'--`
В результате получится следующий SQL запрос:
`SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1`
Запрос выполнится, но вернет уже другой результат. Почему? дело в том, что `--` в sql является идентификатором комментария и поэтому в бд отработает запрос
`SELECT * FROM products WHERE category = 'Gifts'`

Следующий пример
`https://insecure-website.com/products?category=Gifts'+OR+1=1--`
Приведет к запросу
`SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1`
И в результате мы получаем все имеющиеся продукты.

Пример SQL инъекции для нашего сервера
Через ORM
`curl -XGET http://localhost:3000/author?id=00000000-0000-0000-0000-000000000000%27+or+1=1+--`
Через SQL
`curl -XGET http://localhost:3000/author/pure?id=00000000-0000-0000-0000-000000000000%27+or+1=1+--`

К счастью, большинство библиотек, в том числе и на PHP уже имеют защиту от инъекций. Для безопасности рекомендуется работать через ORM или методы, предоставляемые разработчиками библиотек для работы с бд, в которых все спец символы экранируются.

[Хорошая статья про SQL инъекции](https://portswigger.net/web-security/sql-injection)


## Удаление данных из БД

Когда стоит удалять данные из бд, а когда лучше их просто пометить удаленными?
Какие моменты стоит учитывать, что бы решить, удалять данные или нет.

- Команда DELETE необратимая, восстановить данные можно только через резервные копии (если она есть, и сделана не давно, но вы уверены, что хотите с этим возиться?). Поэтому удалять стоит только те данные, которые имеют небольшой срок годности и легко восстанавливаются (например рассчитываемые данные, статистика и т.д.).
- Законы! К примеру GDPR (*General Data Protection Regulation)*, при работе в ЕС. 
- При частом удалении и добавлении небольших записей возникает проблема дефрагментации дисков со всеми вытекающими последствиями.
- Стоит помнить, что при удалении лишний раз вызовется перестроение всех связанных индексов.


## Про масштабирование баз данных

https://highload.today/sharding-i-replikatsiya/

