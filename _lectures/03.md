# Каркас для сервера
Основная цель данной лекции, продемонстрировать логические блоки, которые бывают в проект и упростить понимание структуры проектов, с которыми вы в будущем можете столкнуться. Сегодня большинство современных проектов (не только back-end, но и front-end) строятся с использованием MV*-паттернов. Основная цель данных паттернов: отделить UI-код (View) от кода логики (Presenter, Controller, ViewModel и т. д.) и кода обработки данных (Model). Все они родились от MVC (Model, View,Controller) паттерна.

В результате развития этих паттернов в back-end проектах выделилось 2 больших прослойки:

- Model — слой, отвечающий за бизнес логику и логику обработки данных, который разделился на 2 слоя: бизнес логика и логика работы с данными соответственно. Сам термин model используется для описания моделей (структур) данных. А классы, отвечающие за обработку данных чаще всего имеют префиксы .service или .manager .
- Controller — слой, отвечающий за обработку запросов, включающий в себя:
    - валидацию dto (data transfer object) моделей
    - получение из них данных, необходимых для вызова той или иной логики
    - вызов логики
    - формирование ответа
- View — за представление данных отвечает некий клиент, который пользуется данным API (это хорошая тема для холивара, поэтому IMHO ¯\\\_(ツ)_/¯ )


## Рассмотрим пример популярных движков:

ASP.NET C#

https://github.com/search?l=C%23&q=asp.net+api+template&type=Repositories

JAVA Spring 

https://github.com/search?q=java+api+template&type=Repositories


## Рассмотрим пример проекта в папке  ./_examples/rest

Пинг:

```
curl -XGET http://localhost:3000/ping
```

Очистка БД:

```
curl -XGET http://localhost:3000/clear
```

Список авторов:

```
curl -XGET http://localhost:3000/author
```

Добавление автора Сальвадора Дали:

```
curl --header "Content-Type: application/json" \
    --request POST \
    --data '{ "name": "Dali Salvador", "born": 1904, "died": 1989 }' \
    http://localhost:3000/author
```

Добавление автора Сергея Лукьяненко

```
curl --header "Content-Type: application/json" \
    --request POST \
    --data '{ "name": "Lukjanenko Sergej", "born": 1968 }' \
    http://localhost:3000/author
```


## Пандемия, магазины переходят в онлайн, мы им помогаем, нам надо написать запрос для выставления ссылки для оплаты, как это делать?

Для начала стоит разобраться, что нужно сделать?
Мы получаем модель данных, содержащую в себе информацию о пользователе и о товаре, который он хочет оплатить.

1. Проверяем, есть ли такой пользователь, фактически проводим аутентификацию. Не хочется пускать анонов к биллингу (хотя если будет сильно много желающих, запилим для них донат какой-нибудь).
2. Проверяем товар на наличие, сколько он стоит.
3. Резервируем товар на время покупки.
4. Отправляем в сторонний сервис запрос (к примеру яндекс кассы) для формирования ссылки
5. Получаем идентификатор запроса
6. Создаем в бд запись о покупке с идентификатором запроса
7. Формируем ссылку для оплаты
8. Отправляем её в ответ

Теперь, когда ясно, что, подумаем как? какая логика куда идет? Нужно разбить ответственность между controller и service. Самый простой подход, это представить что controller - это менеджеры, а service - это работники.

Если подумать о роли менеджера, он / она обычно:

- управляет входящими запросами на работу
- решает, какой работник должен выполнять работу
- разбивает работу на большие части
- передает эту работу
- если работа требует, чтобы несколько человек работали над несколькими вещами, организует работу
- но не **выполняет** работу сам (опять же, используя базовый стереотип!)

И рабочий обычно:

- получает заявку от менеджера
- выясняет отдельные детали, необходимые для выполнения запроса
- обычно занимается только задачами, которые он / она должен выполнить
- не несет ответственности за принятие решений о "более широкой" картине (оппа, принцип single responsibility)
- выполняет фактическую работу, необходимую для выполнения задач / запроса
- возвращает выполненную работу менеджеру

Но среди работников никогда не существовало классового равенства (у программистов это описывалось 3 всем знакомыми словами junior middle senior). Так же  и тут. Есть работники, которые умеют выполнять только простые операции, а есть те, кому можно поручить более сложные задачи.

И так, возвращаемся к нашей задаче:

1. Для аутентификации у нас есть отдельная система, передаем ей пришедший токен, получаем информацию о пользователе.
2. Для работы с товарами у нас есть сервис склада товаров. Вот пусть он и отвечает за проверки на наличие, текущие цены, резервирование товара.
3. Мы получили сумму, которую пользователь должен заплатить, передаем эти данные в биллинг сервис.
4. Получаем ссылку от биллинг сервиса и возвращаем её в ответ.

Обработчик запроса будет выглядеть следующим образом


```js
public getPaymentLink(data: PaymentDto): Response<string> {

    const membership: IMembershipService = new BaseMembership();
    const user = membership.getUserByToken(data.token);

    const warehouse: IWareHouseService = new WareHouse();
    const goods = warehouse.reservation(user.userId, data.goodsId, data.goodsCount);

    const billing: IBillingService = new YandexBilling();
    const link = billing.getLink(user.userId, goods.totalPrice);

    return new Response(link);
}
```

И так, получается, у нас есть 3 крутых сервиса, которые содержат бизнес логику:

- IMembershipService - сервис для работы с пользователями,
- IWareHouseService - сервис для работы с товарами,
- IBillingService - сервис для работы с оплатами.

IMembership опустим, чаще всего это готовый плагин, который надо только настроить и пользоваться.

IWareHouseService — а это уже наш самописный сервис, в нем мы по базе проверяем товары, он умеет (как минимум) резервировать товары. Как будет выглядеть эта функция? Опять же разобьем её на этапы:

1. Поиск товара по картотеке.
2. Проверка его на складе.
3. Резервация для пользователя.

```js
export class WareHouse1COhNoo implements IWareHouseService {
    ...

    reservation(userId:string, goodsId:string, count:number): GoodsForPurchase {
        const goods: IGoodsService = new GoodsDbService();

        const goodsInfo = goods.getInfo(goodsId);
        if(goodsInfo === null)
            throw new ProtocolError('Goods not found');

        if(!goods.checkCount(count))
            throw new ProtocolError('Goods are not enough');

        return goods.reservation(userId, goods, count);
    }

    ...
}
```

Доп материалы:

- [Различия между MVVM и остальными MV*-паттернами](https://habr.com/ru/company/mobileup/blog/313538/)

